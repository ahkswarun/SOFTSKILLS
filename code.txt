////bellman's
/*import java.util.*;

public class BellmanFordAlgorithm {
    static class Edge {
        int source, dest, weight;

        Edge(int source, int dest, int weight) {
            this.source = source;
            this.dest = dest;
            this.weight = weight;
        }
    }

    static class Graph {
        int V, E;
        Edge[] edges;

        Graph(int V, int E) {
            this.V = V;
            this.E = E;
            edges = new Edge[E];
        }

        void addEdge(int index, int source, int dest, int weight) {
            edges[index] = new Edge(source, dest, weight);
        }

        void bellmanFord(int source) {
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MAX_VALUE);
            dist[source] = 0;

            // Relax all edges V-1 times
            for (int i = 0; i < V - 1; i++) {
                for (int j = 0; j < E; j++) {
                    int u = edges[j].source;
                    int v = edges[j].dest;
                    int weight = edges[j].weight;
                    if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                        dist[v] = dist[u] + weight;
                    }
                }
            }

            // Check for negative-weight cycles
            for (int i = 0; i < E; i++) {
                int u = edges[i].source;
                int v = edges[i].dest;
                int weight = edges[i].weight;
                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                    System.out.println("Graph contains negative-weight cycle.");
                    return;
                }
            }

            // Print the shortest distances from source to all vertices
            System.out.println("Shortest distances from source vertex " + source + ":");
            for (int i = 0; i < V; i++) {
                System.out.println("Vertex " + i + ": " + dist[i]);
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices: ");
        int V = scanner.nextInt();

        System.out.print("Enter the number of edges: ");
        int E = scanner.nextInt();

        Graph graph = new Graph(V, E);

        System.out.println("Enter the edges and their weights (source destination weight):");
        for (int i = 0; i < E; i++) {
            int source = scanner.nextInt();
            int dest = scanner.nextInt();
            int weight = scanner.nextInt();
            graph.addEdge(i, source, dest, weight);
        }

        System.out.print("Enter the source vertex: ");
        int source = scanner.nextInt();

        graph.bellmanFord(source);
    }
}
*/

/////topological sort
/*
import java.util.*;

public class TopologicalSort {

	// Function to perform DFS and topological sorting
	static void topologicalSortUtil(int v, List<List<Integer>> adj,
									boolean[] visited,
									Stack<Integer> stack)
	{
		// Mark the current node as visited
		visited[v] = true;

		// Recur for all adjacent vertices
		for (int i : adj.get(v)) {
			if (!visited[i])
				topologicalSortUtil(i, adj, visited, stack);
		}

		// Push current vertex to stack which stores the
		// result
		stack.push(v);
	}

	// Function to perform Topological Sort
	static void topologicalSort(List<List<Integer>> adj, int V)
	{
		// Stack to store the result
		Stack<Integer> stack = new Stack<>();
		boolean[] visited = new boolean[V];

		// Call the recursive helper function to store
		// Topological Sort starting from all vertices one
		// by one
		for (int i = 0; i < V; i++) {
			if (!visited[i])
				topologicalSortUtil(i, adj, visited, stack);
		}

		// Print contents of stack
		System.out.print("Topological sorting of the graph: ");
		while (!stack.empty()) {
			System.out.print(stack.pop() + " ");
		}
		System.out.println();
	}

	// Driver code
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices: ");
		int V = scanner.nextInt();

		List<List<Integer>> adj = new ArrayList<>(V);
		for (int i = 0; i < V; i++) {
			adj.add(new ArrayList<>());
		}

		System.out.print("Enter the number of edges: ");
		int E = scanner.nextInt();
		System.out.println("Enter the edges (source destination): ");
		for (int i = 0; i < E; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			adj.get(source).add(destination);
		}

		topologicalSort(adj, V);
	}
}
*/
////heap sort
/*
import java.util.Arrays;
import java.util.Scanner;

public class SortingExample {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the number of elements
        System.out.print("Enter the number of elements: ");
        int n = scanner.nextInt();

        // Create an array to store the elements
        int[] arr = new int[n];

        // Prompt the user to enter the elements
        System.out.println("Enter the elements:");

        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Sort the array
        Arrays.sort(arr);

        // Print the sorted array
        System.out.println("Sorted array:");
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}*/

//////bfs
/*
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

// Class to represent a graph using adjacency list
class Graph {
	int vertices;
	LinkedList<Integer>[] adjList;

	@SuppressWarnings("unchecked") Graph(int vertices)
	{
		this.vertices = vertices;
		adjList = new LinkedList[vertices];
		for (int i = 0; i < vertices; ++i)
			adjList[i] = new LinkedList<>();
	}

	// Function to add an edge to the graph
	void addEdge(int u, int v) { adjList[u].add(v); }

	// Function to perform Breadth First Search on a graph
	// represented using adjacency list
	void bfs(int startNode)
	{
		// Create a queue for BFS
		Queue<Integer> queue = new LinkedList<>();
		boolean[] visited = new boolean[vertices];

		// Mark the current node as visited and enqueue it
		visited[startNode] = true;
		queue.add(startNode);

		// Iterate over the queue
		while (!queue.isEmpty()) {
			// Dequeue a vertex from queue and print it
			int currentNode = queue.poll();
			System.out.print(currentNode + " ");

			// Get all adjacent vertices of the dequeued
			// vertex currentNode If an adjacent has not
			// been visited, then mark it visited and
			// enqueue it
			for (int neighbor : adjList[currentNode]) {
				if (!visited[neighbor]) {
					visited[neighbor] = true;
					queue.add(neighbor);
				}
			}
		}
	}
}

public class Main {
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices in the graph: ");
		int vertices = scanner.nextInt();

		// Create a graph
		Graph graph = new Graph(vertices);

		System.out.print("Enter the number of edges: ");
		int edges = scanner.nextInt();

		System.out.println("Enter the edges (source destination):");
		for (int i = 0; i < edges; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			graph.addEdge(source, destination);
		}

		// Perform BFS traversal starting from vertex 0
		System.out.print(
			"Breadth First Traversal starting from vertex 0: ");
		graph.bfs(0);
	}
}*/

/////dfs
/*
import java.util.*;

// This class represents a
// directed graph using adjacency
// list representation
class Main {
	private int V;
	private LinkedList<Integer>[] adj;

	// Constructor
	@SuppressWarnings("unchecked")
	Main(int v)
	{
		V = v;
		adj = new LinkedList[v];
		for (int i = 0; i < v; ++i)
			adj[i] = new LinkedList<>();
	}

	// Function to add an edge into the graph
	void addEdge(int v, int w)
	{
		// Add w to v's list.
		adj[v].add(w);
	}

	// A function used by DFS
	void DFSUtil(int v, boolean visited[])
	{
		// Mark the current node as visited and print it
		visited[v] = true;
		System.out.print(v + " ");

		// Recur for all the vertices adjacent to this vertex
		Iterator<Integer> i = adj[v].listIterator();
		while (i.hasNext()) {
			int n = i.next();
			if (!visited[n])
				DFSUtil(n, visited);
		}
	}

	// The function to do DFS traversal.
	// It uses recursive DFSUtil()
	void DFS(int v)
	{
		// Mark all the vertices as not visited(set as false by default in java)
		boolean visited[] = new boolean[V];

		// Call the recursive helper function to print DFS traversal
		DFSUtil(v, visited);
	}

	// Driver Code
	public static void main(String args[])
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices in the graph: ");
		int V = scanner.nextInt();
		Main g = new Main(V);

		System.out.print("Enter the number of edges: ");
		int E = scanner.nextInt();
		System.out.println("Enter the edges (source destination):");
		for (int i = 0; i < E; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			g.addEdge(source, destination);
		}

		System.out.print("Enter the starting vertex for DFS traversal: ");
		int startVertex = scanner.nextInt();

		System.out.println("Depth First Traversal:");
		g.DFS(startVertex);
	}
}
*/
////vertical order traversal
/*
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.Vector;
import java.util.*;

public class Main {
	// Tree node
	static class Node {
		int key;
		Node left;
		Node right;

		// Constructor
		Node(int data)
		{
			key = data;
			left = null;
			right = null;
		}
	}
     static Node buildTree(String s) {
        String[] sarr = s.split("\\s+");
        Node root = new Node(Integer.parseInt(sarr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sarr.length) {
            Node current = q.poll();
            if (!sarr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sarr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sarr.length) {
                break;
            }
            if (!sarr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sarr[i]));
                q.add(current.right);
            }
            i++;
        }

        return root;
    }

	// Utility function to store vertical order in map 'm'
	// 'hd' is horizontal distance of current node from
	// root. 'hd' is initially passed as 0
	static void
	getVerticalOrder(Node root, int hd,
					TreeMap<Integer, Vector<Integer> > m)
	{
		// Base case
		if (root == null)
			return;

		// get the vector list at 'hd'
		Vector<Integer> get = m.get(hd);

		// Store current node in map 'm'
		if (get == null) {
			get = new Vector<>();
			get.add(root.key);
		}
		else
			get.add(root.key);

		m.put(hd, get);

		// Store nodes in left subtree
		getVerticalOrder(root.left, hd - 1, m);

		// Store nodes in right subtree
		getVerticalOrder(root.right, hd + 1, m);
	}

	// The main function to print vertical order of a binary
	// tree with the given root
	static void printVerticalOrder(Node root)
{
    // Create a map and store vertical order in map
    // using function getVerticalOrder()
    TreeMap<Integer, Vector<Integer> > m
        = new TreeMap<>();
    int hd = 0;
    getVerticalOrder(root, hd, m);

    // Traverse the map and print nodes at every
    // horizontal distance (hd)
    for (Entry<Integer, Vector<Integer> > entry :
        m.entrySet()) {
        Vector<Integer> nodes = entry.getValue();
        for (Integer node : nodes) {
            System.out.print(node + " ");
        }
        System.out.println();
    }
}

	// Driver code
	public static void main(String[] args)
	{

	    Scanner sc=new Scanner(System.in);
	    String s=sc.nextLine();
	    Node root=buildTree(s);
		System.out.println("Vertical Order traversal is");
		printVerticalOrder(root);
	}
}
*/

/////boundary traversal
/*
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
    static class Node {
        int data;
        Node left, right;

        Node(int item) {
            data = item;
            left = right = null;
        }
    }

    Node root;

    static Node buildTree(String s) {
        String[] sarr = s.split("\\s+");
        Node root = new Node(Integer.parseInt(sarr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sarr.length) {
            Node current = q.poll();
            if (!sarr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sarr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sarr.length) {
                break;
            }
            if (!sarr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sarr[i]));
                q.add(current.right);
            }
            i++;
        }

        return root;
    }

    // A simple function to print leaf nodes of a binary tree
    void printLeaves(Node node) {
        if (node == null)
            return;

        printLeaves(node.left);
        // Print it if it is a leaf node
        if (node.left == null && node.right == null)
            System.out.print(node.data + " ");
        printLeaves(node.right);
    }

    // A function to print all left boundary nodes, except a leaf node.
    // Print the nodes in TOP DOWN manner
    void printBoundaryLeft(Node node) {
        if (node == null)
            return;

        if (node.left != null) {
            // to ensure top down order, print the node
            // before calling itself for left subtree
            System.out.print(node.data + " ");
            printBoundaryLeft(node.left);
        } else if (node.right != null) {
            System.out.print(node.data + " ");
            printBoundaryLeft(node.right);
        }

        // do nothing if it is a leaf node, this way we avoid
        // duplicates in output
    }

    // A function to print all right boundary nodes, except a leaf node
    // Print the nodes in BOTTOM UP manner
    void printBoundaryRight(Node node) {
        if (node == null)
            return;

        if (node.right != null) {
            // to ensure bottom up order, first call for right
            // subtree, then print this node
            printBoundaryRight(node.right);
            System.out.print(node.data + " ");
        } else if (node.left != null) {
            printBoundaryRight(node.left);
            System.out.print(node.data + " ");
        }
        // do nothing if it is a leaf node, this way we avoid
        // duplicates in output
    }

    // A function to do boundary traversal of a given binary tree
    void printBoundary(Node node) {
        if (node == null)
            return;

        System.out.print(node.data + " ");

        // Print the left boundary in top-down manner.
        printBoundaryLeft(node.left);

        // Print all leaf nodes
        printLeaves(node.left);
        printLeaves(node.right);

        // Print the right boundary in bottom-up manner
        printBoundaryRight(node.right);
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        Main tree = new Main();

        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        tree.root = buildTree(s);
        System.out.println("Boundary Traversal of binary tree is ");
        tree.printBoundary(tree.root);
    }
}
*/

////views of tree///
/*
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    public TreeNode(int value) {
        val = value;
        left = right = null;
    }
}

public class TreeViews {

    // Function to perform a level order traversal
    private static List<List<Integer>> levelOrderTraversal(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null)
            return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();
                currentLevel.add(currentNode.val);

                if (currentNode.left != null)
                    queue.offer(currentNode.left);
                if (currentNode.right != null)
                    queue.offer(currentNode.right);
            }
            result.add(currentLevel);
        }
        return result;
    }

    // Function to print the horizontal view of the binary tree
    public static void horizontalView(TreeNode root) {
        Map<Integer, List<Integer>> horizontalMap = new TreeMap<>();
        horizontalViewHelper(root, horizontalMap, 0);

        for (List<Integer> levelNodes : horizontalMap.values()) {
            for (Integer val : levelNodes) {
                System.out.print(val + " ");
            }
        }
    }

    private static void horizontalViewHelper(TreeNode node, Map<Integer, List<Integer>> horizontalMap, int depth) {
        if (node == null)
            return;

        List<Integer> levelNodes = horizontalMap.getOrDefault(depth, new ArrayList<>());
        levelNodes.add(node.val);
        horizontalMap.put(depth, levelNodes);

        horizontalViewHelper(node.left, horizontalMap, depth + 1);
        horizontalViewHelper(node.right, horizontalMap, depth + 1);
    }

    // Function to print the vertical view of the binary tree
    public static void verticalView(TreeNode root) {
        TreeMap<Integer, List<Integer>> verticalMap = new TreeMap<>();
        verticalViewHelper(root, verticalMap, 0);

        for (List<Integer> levelNodes : verticalMap.values()) {
            for (Integer val : levelNodes) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }

    private static void verticalViewHelper(TreeNode node, TreeMap<Integer, List<Integer>> verticalMap, int level) {
        if (node == null)
            return;

        List<Integer> levelNodes = verticalMap.getOrDefault(level, new ArrayList<>());
        levelNodes.add(node.val);
        verticalMap.put(level, levelNodes);

        verticalViewHelper(node.left, verticalMap, level - 1);
        verticalViewHelper(node.right, verticalMap, level + 1);
    }

    // Function to print the left view of the binary tree
    public static void leftView(TreeNode root) {
        leftViewHelper(root, 1);
    }

    private static int maxLevel = 0;

    private static void leftViewHelper(TreeNode node, int level) {
        if (node == null)
            return;

        if (level > maxLevel) {
            System.out.print(node.val + " ");
            maxLevel = level;
        }

        leftViewHelper(node.left, level + 1);
        leftViewHelper(node.right, level + 1);
    }

    // Function to print the right view of the binary tree
    public static void rightView(TreeNode root) {
        maxLevel = 0;
        rightViewHelper(root, 1);
    }

    private static void rightViewHelper(TreeNode node, int level) {
        if (node == null)
            return;

        if (level > maxLevel) {
            System.out.print(node.val + " ");
            maxLevel = level;
        }

        rightViewHelper(node.right, level + 1);
        rightViewHelper(node.left, level + 1);
    }

    // Function to print the top view of the binary tree
    public static void topView(TreeNode root) {
        TreeMap<Integer, Integer> topViewMap = new TreeMap<>();
        topViewHelper(root, topViewMap, 0);

        for (Integer val : topViewMap.values()) {
            System.out.print(val + " ");
        }
    }

    private static void topViewHelper(TreeNode node, TreeMap<Integer, Integer> topViewMap, int level) {
        if (node == null)
            return;

        if (!topViewMap.containsKey(level)) {
            topViewMap.put(level, node.val);
        }

        topViewHelper(node.left, topViewMap, level - 1);
        topViewHelper(node.right, topViewMap, level + 1);
    }

    // Function to print the bottom view of the binary tree
    public static void bottomView(TreeNode root) {
        TreeMap<Integer, Integer> bottomViewMap = new TreeMap<>();
        bottomViewHelper(root, bottomViewMap, 0);

        for (Integer val : bottomViewMap.values()) {
            System.out.print(val + " ");
        }
    }

    private static void bottomViewHelper(TreeNode node, TreeMap<Integer, Integer> bottomViewMap, int level) {
        if (node == null)
            return;

        bottomViewMap.put(level, node.val);

        bottomViewHelper(node.left, bottomViewMap, level - 1);
        bottomViewHelper(node.right, bottomViewMap, level + 1);
    }

    // Function to build the binary tree from array input
    public static TreeNode buildTree(Integer[] array, int index) {
        TreeNode root = null;
        if (index < array.length && array[index] != null) {
            root = new TreeNode(array[index]);
            root.left = buildTree(array, 2 * index + 1);
            root.right = buildTree(array, 2 * index + 2);
        }
        return root;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the elements of the binary tree separated by spaces (use null for missing nodes):");
        String[] input = scanner.nextLine().split(" ");

        Integer[] array = new Integer[input.length];
        for (int i = 0; i < input.length; i++) {
            if (input[i].equals("null")) {
                array[i] = null;
            } else {
                array[i] = Integer.parseInt(input[i]);
            }
        }

        TreeNode root = buildTree(array, 0);

        System.out.println("Horizontal View:");
        horizontalView(root);
        System.out.println("\nVertical View:");
        verticalView(root);
        System.out.println("\nLeft View:");
        leftView(root);
        System.out.println("\nRight View:");
        rightView(root);
        System.out.println("\nTop View:");
        topView(root);
        System.out.println("\nBottom View:");
        bottomView(root);

        scanner.close();
    }
}
*/
////binomila heap
/*
import java.util.*;

class BinomialHeapNode {
    int key, degree;
    BinomialHeapNode parent, child, sibling;

    public BinomialHeapNode(int key) {
        this.key = key;
        this.degree = 0;
        this.parent = this.child = this.sibling = null;
    }
}

public class BinomialHeap {
    private BinomialHeapNode head;

    public BinomialHeap() {
        head = null;
    }

    private BinomialHeapNode mergeTrees(BinomialHeapNode tree1, BinomialHeapNode tree2) {
        if (tree1.key < tree2.key) {
            tree1.sibling = tree2.child;
            tree2.child = tree1;
            return tree2;
        } else {
            tree2.sibling = tree1.child;
            tree1.child = tree2;
            return tree1;
        }
    }

    private BinomialHeapNode mergeHeaps(BinomialHeapNode heap1, BinomialHeapNode heap2) {
        BinomialHeapNode dummy = new BinomialHeapNode(0);
        BinomialHeapNode current = dummy;

        while (heap1 != null && heap2 != null) {
            if (heap1.degree <= heap2.degree) {
                current.sibling = heap1;
                heap1 = heap1.sibling;
            } else {
                current.sibling = heap2;
                heap2 = heap2.sibling;
            }
            current = current.sibling;
        }

        current.sibling = (heap1 != null) ? heap1 : heap2;
        return dummy.sibling;
    }

    public void insert(int key) {
        BinomialHeapNode newNode = new BinomialHeapNode(key);
        head = mergeHeaps(head, newNode);
        BinomialHeapNode prev = null;
        BinomialHeapNode current = head;
        BinomialHeapNode next = current.sibling;

        while (next != null) {
            if ((current.degree != next.degree) || (next.sibling != null && next.sibling.degree == current.degree)) {
                prev = current;
                current = next;
            } else {
                if (current.key <= next.key) {
                    current.sibling = next.sibling;
                    current = mergeTrees(current, next);
                } else {
                    if (prev == null) {
                        head = next;
                    } else {
                        prev.sibling = next;
                    }
                    current = mergeTrees(next, current);
                    current = next;
                }
            }
            next = current.sibling;
        }
    }

    public void deleteMin() {
        if (head == null) {
            System.out.println("Heap is empty");
            return;
        }

        BinomialHeapNode minPrev = null;
        BinomialHeapNode minCurrent = head;
        BinomialHeapNode current = minCurrent.sibling;
        BinomialHeapNode prev = minCurrent;

        while (current != null) {
            if (current.key < minCurrent.key) {
                minCurrent = current;
                minPrev = prev;
            }
            prev = current;
            current = current.sibling;
        }

        if (minPrev == null) {
            head = minCurrent.sibling;
        } else {
            minPrev.sibling = minCurrent.sibling;
        }

        BinomialHeapNode newHead = null;
        BinomialHeapNode child = minCurrent.child;

        while (child != null) {
            BinomialHeapNode next = child.sibling;
            child.sibling = newHead;
            newHead = child;
            child = next;
        }

        BinomialHeapNode newHeap = mergeHeaps(head, newHead);
        head = newHeap;
    }

    public void displayHeap(BinomialHeapNode node) {
        while (node != null) {
            System.out.print(node.key + " ");
            displayHeap(node.child);
            node = node.sibling;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BinomialHeap heap = new BinomialHeap();

        while (true) {
            System.out.println("\n1. Insert");
            System.out.println("2. Delete Min");
            System.out.println("3. Display");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter key to insert: ");
                    int key = scanner.nextInt();
                    heap.insert(key);
                    break;
                case 2:
                    heap.deleteMin();
                    System.out.println("Min deleted");
                    break;
                case 3:
                    System.out.print("Heap: ");
                    heap.displayHeap(heap.head);
                    break;
                case 4:
                    scanner.close();
                    System.exit(0);
                default:
                    System.out.println("Invalid choice");
            }
        }
    }
}
*/
/////recover bst
/*
import java.util.*;

class Node {
    int val;
    Node left;
    Node right;

    Node(int data) {
        this.val = data;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    static Node firstIncorrect = null;
    static Node secondIncorrect = null;
    static Node prev = null;

    public static Node buildTree(String s) {
        String[] sArr = s.split(" ");
        Node root = new Node(Integer.parseInt(sArr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sArr.length) {
            Node current = q.poll();
            if (!sArr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sArr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sArr.length)
                break;
            if (!sArr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sArr[i]));
                q.add(current.right);
            }
            i++;
        }
        return root;
    }

    public static void inOrder(Node root) {
        if (root == null)
            return;

        inOrder(root.left);

        if (prev != null && prev.val >= root.val) {
            if (firstIncorrect == null) {
                firstIncorrect = prev;
            }
            secondIncorrect = root;
        }

        prev = root;

        inOrder(root.right);
    }

    public static void recoverTree(Node root) {
        inOrder(root);

        int temp = firstIncorrect.val;
        firstIncorrect.val = secondIncorrect.val;
        secondIncorrect.val = temp;

        printInOrder(root);
    }

    public static void printInOrder(Node root) {
        if (root == null)
            return;

        printInOrder(root.left);
        System.out.print(root.val + " ");
        printInOrder(root.right);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        Node root = buildTree(s);
        prev = new Node(Integer.MIN_VALUE);
        recoverTree(root);
    }
}*/	

////k ary heap
/*
import java.util.ArrayList;
import java.util.List;

class KTreeNode {
    int val;
    List<KTreeNode> children;

    KTreeNode(int val) {
        this.val = val;
        this.children = new ArrayList<>();
    }
}

public class KaryTree {
    KTreeNode root;
    int k;

    KaryTree(int val, int k) {
        this.root = new KTreeNode(val);
        this.k = k;
    }

    void addChild(int parentVal, int childVal) {
        KTreeNode parentNode = findNode(root, parentVal);
        if (parentNode != null && parentNode.children.size() < k) {
            KTreeNode childNode = new KTreeNode(childVal);
            parentNode.children.add(childNode);
        } else {
            System.out.println("Parent not found or adding child exceeds k-ary constraint.");
        }
    }

    void addChildAtIndex(int parentVal, int childVal, int index) {
        KTreeNode parentNode = findNode(root, parentVal);
        if (parentNode != null && index >= 0 && index < parentNode.children.size()) {
            KTreeNode childNode = new KTreeNode(childVal);
            parentNode.children.add(index, childNode);
        } else {
            System.out.println("Parent not found or index out of bounds.");
        }
    }

    boolean deleteNode(int val) {
        if (root == null) return false;
        if (root.val == val) {
            root = null;
            return true;
        }
        return deleteNode(root, val);
    }

    private boolean deleteNode(KTreeNode node, int val) {
        for (int i = 0; i < node.children.size(); i++) {
            if (node.children.get(i).val == val) {
                node.children.remove(i);
                return true;
            }
            if (deleteNode(node.children.get(i), val)) {
                return true;
            }
        }
        return false;
    }

    void replaceNodeValue(int val, int newVal) {
        KTreeNode node = findNode(root, val);
        if (node != null) {
            node.val = newVal;
        } else {
            System.out.println("Node not found.");
        }
    }

    private KTreeNode findNode(KTreeNode node, int val) {
        if (node == null) return null;
        if (node.val == val) return node;
        for (KTreeNode child : node.children) {
            KTreeNode found = findNode(child, val);
            if (found != null) return found;
        }
        return null;
    }

    void printTree() {
        printTree(root, 0);
    }

    private void printTree(KTreeNode node, int depth) {
        if (node == null) return;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            sb.append("  ");
        }
        sb.append(node.val);
        System.out.println(sb.toString());
        for (KTreeNode child : node.children) {
            printTree(child, depth + 1);
        }
    }

    public static void main(String[] args) {
        KaryTree tree = new KaryTree(1, 3);
        tree.addChild(1, 2);
        tree.addChild(1, 3);
        tree.addChild(2, 4);
        tree.addChild(2, 5);
        tree.addChild(3, 6);
        tree.addChild(3, 7);
        tree.addChild(3, 8);

        System.out.println("K-ary Tree:");
        tree.printTree();

        tree.deleteNode(4); // Delete node with value 4
        tree.addChildAtIndex(2, 9, 1); // Add node with value 9 as the second child of node with value 2
        tree.replaceNodeValue(6, 10); // Replace the value of node with value 6 with 10

        System.out.println("\nModified K-ary Tree:");
        tree.printTree();
    }
}
*/
