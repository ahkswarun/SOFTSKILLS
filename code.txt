STS java
//belmannâ€™s
/*import java.util.*;

public class BellmanFordAlgorithm {
    static class Edge {
        int source, dest, weight;

        Edge(int source, int dest, int weight) {
            this.source = source;
            this.dest = dest;
            this.weight = weight;
        }
    }

    static class Graph {
        int V, E;
        Edge[] edges;

        Graph(int V, int E) {
            this.V = V;
            this.E = E;
            edges = new Edge[E];
        }

        void addEdge(int index, int source, int dest, int weight) {
            edges[index] = new Edge(source, dest, weight);
        }

        void bellmanFord(int source) {
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MAX_VALUE);
            dist[source] = 0;

            // Relax all edges V-1 times
            for (int i = 0; i < V - 1; i++) {
                for (int j = 0; j < E; j++) {
                    int u = edges[j].source;
                    int v = edges[j].dest;
                    int weight = edges[j].weight;
                    if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                        dist[v] = dist[u] + weight;
                    }
                }
            }

            // Check for negative-weight cycles
            for (int i = 0; i < E; i++) {
                int u = edges[i].source;
                int v = edges[i].dest;
                int weight = edges[i].weight;
                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                    System.out.println("Graph contains negative-weight cycle.");
                    return;
                }
            }

            // Print the shortest distances from source to all vertices
            System.out.println("Shortest distances from source vertex " + source + ":");
            for (int i = 0; i < V; i++) {
                System.out.println("Vertex " + i + ": " + dist[i]);
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices: ");
        int V = scanner.nextInt();

        System.out.print("Enter the number of edges: ");
        int E = scanner.nextInt();

        Graph graph = new Graph(V, E);

        System.out.println("Enter the edges and their weights (source destination weight):");
        for (int i = 0; i < E; i++) {
            int source = scanner.nextInt();
            int dest = scanner.nextInt();
            int weight = scanner.nextInt();
            graph.addEdge(i, source, dest, weight);
        }

        System.out.print("Enter the source vertex: ");
        int source = scanner.nextInt();

        graph.bellmanFord(source);
    }
}*/
/////topological sort
/*
import java.util.*;

public class TopologicalSort {

	// Function to perform DFS and topological sorting
	static void topologicalSortUtil(int v, List<List<Integer>> adj,
									boolean[] visited,
									Stack<Integer> stack)
	{
		// Mark the current node as visited
		visited[v] = true;

		// Recur for all adjacent vertices
		for (int i : adj.get(v)) {
			if (!visited[i])
				topologicalSortUtil(i, adj, visited, stack);
		}

		// Push current vertex to stack which stores the
		// result
		stack.push(v);
	}

	// Function to perform Topological Sort
	static void topologicalSort(List<List<Integer>> adj, int V)
	{
		// Stack to store the result
		Stack<Integer> stack = new Stack<>();
		boolean[] visited = new boolean[V];

		// Call the recursive helper function to store
		// Topological Sort starting from all vertices one
		// by one
		for (int i = 0; i < V; i++) {
			if (!visited[i])
				topologicalSortUtil(i, adj, visited, stack);
		}

		// Print contents of stack
		System.out.print(
			"Topological sorting of the graph: ");
		while (!stack.empty()) {
			System.out.print(stack.pop() + " ");
		}
		System.out.println();
	}

	// Driver code
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices: ");
		int V = scanner.nextInt();

		List<List<Integer>> adj = new ArrayList<>(V);
		for (int i = 0; i < V; i++) {
			adj.add(new ArrayList<>());
		}

		System.out.print("Enter the number of edges: ");
		int E = scanner.nextInt();
		System.out.println("Enter the edges (source destination): ");
		for (int i = 0; i < E; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			adj.get(source).add(destination);
		}

		topologicalSort(adj, V);
	}
}
*/
////heap sort
/*
import java.util.Arrays;
import java.util.Scanner;

public class SortingExample {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the number of elements
        System.out.print("Enter the number of elements: ");
        int n = scanner.nextInt();

        // Create an array to store the elements
        int[] arr = new int[n];

        // Prompt the user to enter the elements
        System.out.println("Enter the elements:");

        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Sort the array
        Arrays.sort(arr);

        // Print the sorted array
        System.out.println("Sorted array:");
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}
*/

//////bfs
/*
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

// Class to represent a graph using adjacency list
class Graph {
    int vertices;
    LinkedList<Integer>[] adjList;

    @SuppressWarnings("unchecked")
    Graph(int vertices) {
        this.vertices = vertices;
        adjList = new LinkedList[vertices];
        for (int i = 0; i < vertices; ++i)
            adjList[i] = new LinkedList<>();
    }

    // Function to add an edge to the graph
    void addEdge(int u, int v) {
        adjList[u].add(v);
    }

    // Function to perform Breadth First Search on a graph
    // represented using adjacency list
    void bfs(int startNode) {
        // Create a queue for BFS
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[vertices];

        // Mark the current node as visited and enqueue it
        visited[startNode] = true;
        queue.add(startNode);

        // Iterate over the queue
        while (!queue.isEmpty()) {
            // Dequeue a vertex from queue and print it
            int currentNode = queue.poll();
            System.out.print(currentNode + " ");

            // Get all adjacent vertices of the dequeued
            // vertex currentNode If an adjacent has not
            // been visited, then mark it visited and
            // enqueue it
            for (int neighbor : adjList[currentNode]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.add(neighbor);
                }
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices in the graph: ");
        int vertices = scanner.nextInt();

        // Create a graph
        Graph graph = new Graph(vertices);

        System.out.print("Enter the number of edges: ");
        int edges = scanner.nextInt();

        System.out.println("Enter the edges (source destination):");
        for (int i = 0; i < edges; i++) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            graph.addEdge(source, destination);
        }

        System.out.print("Enter the source vertex for BFS: ");
        int sourceVertex = scanner.nextInt();

        // Perform BFS traversal starting from the specified source vertex
        System.out.print("Breadth First Traversal starting from vertex " + sourceVertex + ": ");
        graph.bfs(sourceVertex);
    }
}
*/

/////dfs
/*
import java.util.*;

// This class represents a
// directed graph using adjacency
// list representation
class Main {
	private int V;
	private LinkedList<Integer>[] adj;

	// Constructor
	@SuppressWarnings("unchecked")
	Main(int v)
	{
		V = v;
		adj = new LinkedList[v];
		for (int i = 0; i < v; ++i)
			adj[i] = new LinkedList();
	}

	// Function to add an edge into the graph
	void addEdge(int v, int w)
	{
		// Add w to v's list.
		adj[v].add(w);
	}

	// A function used by DFS
	void DFSUtil(int v, boolean visited[])
	{
		// Mark the current node as visited and print it
		visited[v] = true;
		System.out.print(v + " ");

		// Recur for all the vertices adjacent to this vertex
		Iterator<Integer> i = adj[v].listIterator();
		while (i.hasNext()) {
			int n = i.next();
			if (!visited[n])
				DFSUtil(n, visited);
		}
	}

	// The function to do DFS traversal.
	// It uses recursive DFSUtil()
	void DFS(int v)
	{
		// Mark all the vertices as not visited(set as false by default in java)
		boolean visited[] = new boolean[V];

		// Call the recursive helper function to print DFS traversal
		DFSUtil(v, visited);
	}

	// Driver Code
	public static void main(String args[])
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices in the graph: ");
		int V = scanner.nextInt();
		Main g = new Main(V);

		System.out.print("Enter the number of edges: ");
		int E = scanner.nextInt();
		System.out.println("Enter the edges (source destination):");
		for (int i = 0; i < E; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			g.addEdge(source, destination);
		}

		System.out.print("Enter the starting vertex for DFS traversal: ");
		int startVertex = scanner.nextInt();

		System.out.println("Depth First Traversal:");
		g.DFS(startVertex);
	}
}
*/
////vertical order traversal
/*
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.Vector;
import java.util.*;

public class Main {
	// Tree node
	static class Node {
		int key;
		Node left;
		Node right;

		// Constructor
		Node(int data)
		{
			key = data;
			left = null;
			right = null;
		}
	}
     static Node buildTree(String s) {
        String[] sarr = s.split("\\s+");
        Node root = new Node(Integer.parseInt(sarr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sarr.length) {
            Node current = q.poll();
            if (!sarr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sarr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sarr.length) {
                break;
            }
            if (!sarr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sarr[i]));
                q.add(current.right);
            }
            i++;
        }

        return root;
    }

	// Utility function to store vertical order in map 'm'
	// 'hd' is horizontal distance of current node from
	// root. 'hd' is initially passed as 0
	static void
	getVerticalOrder(Node root, int hd,
					TreeMap<Integer, Vector<Integer> > m)
	{
		// Base case
		if (root == null)
			return;

		// get the vector list at 'hd'
		Vector<Integer> get = m.get(hd);

		// Store current node in map 'm'
		if (get == null) {
			get = new Vector<>();
			get.add(root.key);
		}
		else
			get.add(root.key);

		m.put(hd, get);

		// Store nodes in left subtree
		getVerticalOrder(root.left, hd - 1, m);

		// Store nodes in right subtree
		getVerticalOrder(root.right, hd + 1, m);
	}

	// The main function to print vertical order of a binary
	// tree with the given root
	static void printVerticalOrder(Node root)
{
    // Create a map and store vertical order in map
    // using function getVerticalOrder()
    TreeMap<Integer, Vector<Integer> > m
        = new TreeMap<>();
    int hd = 0;
    getVerticalOrder(root, hd, m);

    // Traverse the map and print nodes at every
    // horizontal distance (hd)
    for (Entry<Integer, Vector<Integer> > entry :
        m.entrySet()) {
        Vector<Integer> nodes = entry.getValue();
        for (Integer node : nodes) {
            System.out.print(node + " ");
        }
        System.out.println();
    }
}

	// Driver code
	public static void main(String[] args)
	{

	    Scanner sc=new Scanner(System.in);
	    String s=sc.nextLine();
	    Node root=buildTree(s);
		System.out.println("Vertical Order traversal is");
		printVerticalOrder(root);
	}
}
*/

/////boundary traversal
/*
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
    static class Node {
        int data;
        Node left, right;

        Node(int item) {
            data = item;
            left = right = null;
        }
    }

    Node root;

    static Node buildTree(String s) {
        String[] sarr = s.split("\\s+");
        Node root = new Node(Integer.parseInt(sarr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sarr.length) {
            Node current = q.poll();
            if (!sarr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sarr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sarr.length) {
                break;
            }
            if (!sarr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sarr[i]));
                q.add(current.right);
            }
            i++;
        }

        return root;
    }

    // A simple function to print leaf nodes of a binary tree
    void printLeaves(Node node) {
        if (node == null)
            return;

        printLeaves(node.left);
        // Print it if it is a leaf node
        if (node.left == null && node.right == null)
            System.out.print(node.data + " ");
        printLeaves(node.right);
    }

    // A function to print all left boundary nodes, except a leaf node.
    // Print the nodes in TOP DOWN manner
    void printBoundaryLeft(Node node) {
        if (node == null)
            return;

        if (node.left != null) {
            // to ensure top down order, print the node
            // before calling itself for left subtree
            System.out.print(node.data + " ");
            printBoundaryLeft(node.left);
        } else if (node.right != null) {
            System.out.print(node.data + " ");
            printBoundaryLeft(node.right);
        }

        // do nothing if it is a leaf node, this way we avoid
        // duplicates in output
    }

    // A function to print all right boundary nodes, except a leaf node
    // Print the nodes in BOTTOM UP manner
    void printBoundaryRight(Node node) {
        if (node == null)
            return;

        if (node.right != null) {
            // to ensure bottom up order, first call for right
            // subtree, then print this node
            printBoundaryRight(node.right);
            System.out.print(node.data + " ");
        } else if (node.left != null) {
            printBoundaryRight(node.left);
            System.out.print(node.data + " ");
        }
        // do nothing if it is a leaf node, this way we avoid
        // duplicates in output
    }

    // A function to do boundary traversal of a given binary tree
    void printBoundary(Node node) {
        if (node == null)
            return;

        System.out.print(node.data + " ");

        // Print the left boundary in top-down manner.
        printBoundaryLeft(node.left);

        // Print all leaf nodes
        printLeaves(node.left);
        printLeaves(node.right);

        // Print the right boundary in bottom-up manner
        printBoundaryRight(node.right);
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        Main tree = new Main();

        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        tree.root = buildTree(s);
        System.out.println("Boundary Traversal of binary tree is ");
        tree.printBoundary(tree.root);
    }
}
*/

////views of tree////////
/*
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    public TreeNode(int value) {
        val = value;
        left = right = null;
    }
}

public class TreeViews {

    // Function to perform a level order traversal
    private static List<List<Integer>> levelOrderTraversal(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null)
            return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();
                currentLevel.add(currentNode.val);

                if (currentNode.left != null)
                    queue.offer(currentNode.left);
                if (currentNode.right != null)
                    queue.offer(currentNode.right);
            }
            result.add(currentLevel);
        }
        return result;
    }

    // Function to print the horizontal view of the binary tree
    public static void horizontalView(TreeNode root) {
        Map<Integer, List<Integer>> horizontalMap = new TreeMap<>();
        horizontalViewHelper(root, horizontalMap, 0);

        for (List<Integer> levelNodes : horizontalMap.values()) {
            for (Integer val : levelNodes) {
                System.out.print(val + " ");
            }
        }
    }

    private static void horizontalViewHelper(TreeNode node, Map<Integer, List<Integer>> horizontalMap, int depth) {
        if (node == null)
            return;

        List<Integer> levelNodes = horizontalMap.getOrDefault(depth, new ArrayList<>());
        levelNodes.add(node.val);
        horizontalMap.put(depth, levelNodes);

        horizontalViewHelper(node.left, horizontalMap, depth + 1);
        horizontalViewHelper(node.right, horizontalMap, depth + 1);
    }

    // Function to print the vertical view of the binary tree
    public static void verticalView(TreeNode root) {
        TreeMap<Integer, List<Integer>> verticalMap = new TreeMap<>();
        verticalViewHelper(root, verticalMap, 0);

        for (List<Integer> levelNodes : verticalMap.values()) {
            for (Integer val : levelNodes) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }

    private static void verticalViewHelper(TreeNode node, TreeMap<Integer, List<Integer>> verticalMap, int level) {
        if (node == null)
            return;

        List<Integer> levelNodes = verticalMap.getOrDefault(level, new ArrayList<>());
        levelNodes.add(node.val);
        verticalMap.put(level, levelNodes);

        verticalViewHelper(node.left, verticalMap, level - 1);
        verticalViewHelper(node.right, verticalMap, level + 1);
    }

    // Function to print the left view of the binary tree
    public static void leftView(TreeNode root) {
        leftViewHelper(root, 1);
    }

    private static int maxLevel = 0;

    private static void leftViewHelper(TreeNode node, int level) {
        if (node == null)
            return;

        if (level > maxLevel) {
            System.out.print(node.val + " ");
            maxLevel = level;
        }

        leftViewHelper(node.left, level + 1);
        leftViewHelper(node.right, level + 1);
    }

    // Function to print the right view of the binary tree
    public static void rightView(TreeNode root) {
        maxLevel = 0;
        rightViewHelper(root, 1);
    }

    private static void rightViewHelper(TreeNode node, int level) {
        if (node == null)
            return;

        if (level > maxLevel) {
            System.out.print(node.val + " ");
            maxLevel = level;
        }

        rightViewHelper(node.right, level + 1);
        rightViewHelper(node.left, level + 1);
    }

    // Function to print the top view of the binary tree
    public static void topView(TreeNode root) {
        TreeMap<Integer, Integer> topViewMap = new TreeMap<>();
        topViewHelper(root, topViewMap, 0);

        for (Integer val : topViewMap.values()) {
            System.out.print(val + " ");
        }
    }

    private static void topViewHelper(TreeNode node, TreeMap<Integer, Integer> topViewMap, int level) {
        if (node == null)
            return;

        if (!topViewMap.containsKey(level)) {
            topViewMap.put(level, node.val);
        }

        topViewHelper(node.left, topViewMap, level - 1);
        topViewHelper(node.right, topViewMap, level + 1);
    }

    // Function to print the bottom view of the binary tree
    public static void bottomView(TreeNode root) {
        TreeMap<Integer, Integer> bottomViewMap = new TreeMap<>();
        bottomViewHelper(root, bottomViewMap, 0);

        for (Integer val : bottomViewMap.values()) {
            System.out.print(val + " ");
        }
    }

    private static void bottomViewHelper(TreeNode node, TreeMap<Integer, Integer> bottomViewMap, int level) {
        if (node == null)
            return;

        bottomViewMap.put(level, node.val);

        bottomViewHelper(node.left, bottomViewMap, level - 1);
        bottomViewHelper(node.right, bottomViewMap, level + 1);
    }

    // Function to build the binary tree from array input
    public static TreeNode buildTree(Integer[] array, int index) {
        TreeNode root = null;
        if (index < array.length && array[index] != null) {
            root = new TreeNode(array[index]);
            root.left = buildTree(array, 2 * index + 1);
            root.right = buildTree(array, 2 * index + 2);
        }
        return root;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the elements of the binary tree separated by spaces (use null for missing nodes):");
        String[] input = scanner.nextLine().split(" ");

        Integer[] array = new Integer[input.length];
        for (int i = 0; i < input.length; i++) {
            if (input[i].equals("null")) {
                array[i] = null;
            } else {
                array[i] = Integer.parseInt(input[i]);
            }
        }

        TreeNode root = buildTree(array, 0);

        System.out.println("Horizontal View:");
        horizontalView(root);
        System.out.println("\nVertical View:");
        verticalView(root);
        System.out.println("\nLeft View:");
        leftView(root);
        System.out.println("\nRight View:");
        rightView(root);
        System.out.println("\nTop View:");
        topView(root);
        System.out.println("\nBottom View:");
        bottomView(root);

        scanner.close();
    }
}
*/
////binomial heap/////
/*
import java.util.*;

class BinomialHeapNode {
    int key, degree;
    BinomialHeapNode parent, child, sibling;

    public BinomialHeapNode(int key) {
        this.key = key;
        this.degree = 0;
        this.parent = this.child = this.sibling = null;
    }
}

public class BinomialHeap {
    private BinomialHeapNode head;

    public BinomialHeap() {
        head = null;
    }

    private BinomialHeapNode mergeTrees(BinomialHeapNode tree1, BinomialHeapNode tree2) {
        if (tree1.key < tree2.key) {
            tree1.sibling = tree2.child;
            tree2.child = tree1;
            return tree2;
        } else {
            tree2.sibling = tree1.child;
            tree1.child = tree2;
            return tree1;
        }
    }

    private BinomialHeapNode mergeHeaps(BinomialHeapNode heap1, BinomialHeapNode heap2) {
        BinomialHeapNode dummy = new BinomialHeapNode(0);
        BinomialHeapNode current = dummy;

        while (heap1 != null && heap2 != null) {
            if (heap1.degree <= heap2.degree) {
                current.sibling = heap1;
                heap1 = heap1.sibling;
            } else {
                current.sibling = heap2;
                heap2 = heap2.sibling;
            }
            current = current.sibling;
        }

        current.sibling = (heap1 != null) ? heap1 : heap2;
        return dummy.sibling;
    }

    public void insert(int key) {
        BinomialHeapNode newNode = new BinomialHeapNode(key);
        head = mergeHeaps(head, newNode);
        BinomialHeapNode prev = null;
        BinomialHeapNode current = head;
        BinomialHeapNode next = current.sibling;

        while (next != null) {
            if ((current.degree != next.degree) || (next.sibling != null && next.sibling.degree == current.degree)) {
                prev = current;
                current = next;
            } else {
                if (current.key <= next.key) {
                    current.sibling = next.sibling;
                    current = mergeTrees(current, next);
                } else {
                    if (prev == null) {
                        head = next;
                    } else {
                        prev.sibling = next;
                    }
                    current = mergeTrees(next, current);
                    current = next;
                }
            }
            next = current.sibling;
        }
    }

    public void deleteMin() {
        if (head == null) {
            System.out.println("Heap is empty");
            return;
        }

        BinomialHeapNode minPrev = null;
        BinomialHeapNode minCurrent = head;
        BinomialHeapNode current = minCurrent.sibling;
        BinomialHeapNode prev = minCurrent;

        while (current != null) {
            if (current.key < minCurrent.key) {
                minCurrent = current;
                minPrev = prev;
            }
            prev = current;
            current = current.sibling;
        }

        if (minPrev == null) {
            head = minCurrent.sibling;
        } else {
            minPrev.sibling = minCurrent.sibling;
        }

        BinomialHeapNode newHead = null;
        BinomialHeapNode child = minCurrent.child;

        while (child != null) {
            BinomialHeapNode next = child.sibling;
            child.sibling = newHead;
            newHead = child;
            child = next;
        }

        BinomialHeapNode newHeap = mergeHeaps(head, newHead);
        head = newHeap;
    }

    public void displayHeap(BinomialHeapNode node) {
        while (node != null) {
            System.out.print(node.key + " ");
            displayHeap(node.child);
            node = node.sibling;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BinomialHeap heap = new BinomialHeap();

        while (true) {
            System.out.println("\n1. Insert");
            System.out.println("2. Delete Min");
            System.out.println("3. Display");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter key to insert: ");
                    int key = scanner.nextInt();
                    heap.insert(key);
                    break;
                case 2:
                    heap.deleteMin();
                    System.out.println("Min deleted");
                    break;
                case 3:
                    System.out.print("Heap: ");
                    heap.displayHeap(heap.head);
                    break;
                case 4:
                    scanner.close();
                    System.exit(0);
                default:
                    System.out.println("Invalid choice");
            }
        }
    }
}
*/

//////k-ary heap///
/*
import java.util.Scanner;
import java.util.Arrays;
import java.util.NoSuchElementException;
class DaryHeap    
{
    private int d;
    private int heapSize;
    private int[] heap;
    public DaryHeap(int capacity, int numChild)
    {
        heapSize = 0;
        d = numChild;
        heap = new int[capacity + 1];
        Arrays.fill(heap, -1);
    }
    public boolean isEmpty( )
    {
        return heapSize == 0;
    }
    public boolean isFull( )
    {
        return heapSize == heap.length;
    }
public void clear( )
    {
        heapSize = 0; }
        
        private int parent(int i) 
    {
        return (i - 1)/d;
    }
    private int kthChild(int i, int k) 
    {
        return d * i + k;
    }
public void insert(int x)
    {
        if (isFull( ) )
            throw new NoSuchElementException("Overflow Exception");
        heap[heapSize++] = x;
        heapifyUp(heapSize - 1);
    }
    public int findMin( )
    {
        if (isEmpty() )
            throw new NoSuchElementException("Underflow Exception");           
        return heap[0];
    }
 public int delete(int ind)
    {
if (isEmpty() )
            throw new NoSuchElementException("Underflow Exception");
        int keyItem = heap[ind];
        heap[ind] = heap[heapSize - 1];
        heapSize--;
        heapifyDown(ind);        
        return keyItem;
    }
    private void heapifyUp(int childInd)
    {
        int tmp = heap[childInd];    
        while (childInd > 0 && tmp < heap[parent(childInd)])
        {
            heap[childInd] = heap[ parent(childInd) ];
            childInd = parent(childInd);
        }                   
        heap[childInd] = tmp;
    }
    private void heapifyDown(int ind)
    {
        int child;
        int tmp = heap[ ind ];
        while (kthChild(ind, 1) < heapSize)
        {
            child = minChild(ind);
            if (heap[child] < tmp)
                heap[ind] = heap[child];
            else
                break;
            ind = child;
        }
        heap[ind] = tmp;
    }
    private int minChild(int ind) 
    {
        int bestChild = kthChild(ind, 1);
        int k = 2;
        int pos = kthChild(ind, k);
        while ((k <= d) && (pos < heapSize)) 
        {
            if (heap[pos] < heap[bestChild]) 
                bestChild = pos;
            pos = kthChild(ind, k++);
        }    
        return bestChild;
    }
    public void printHeap()
    {
        System.out.print("\nHeap = ");
        for (int i = 0; i < heapSize; i++)
            System.out.print(heap[i] +" ");
        System.out.println();
    }     
}
public class Main
{
    public static void main(String[] args)
    {
        Scanner scan = new Scanner(System.in);
        System.out.println("Enter size and D of D-ary Heap");
        DaryHeap dh = new DaryHeap(scan.nextInt(), scan.nextInt() );
        char ch;
        do    
        {    
            System.out.println("\nD-ary Heap Operations\n");
            System.out.println("1. insert ");
            System.out.println("2. delete");
            System.out.println("3. check full");
            System.out.println("4. check empty");
            System.out.println("5. clear");
            boolean chk;       
            int choice = scan.nextInt();            
            switch (choice)
            {
            case 1 : 
                try
                {
                    System.out.println("Enter integer element to insert");
                    dh.insert( scan.nextInt() ); 
                }
                catch (Exception e)
                {
               System.out.println(e.getMessage() );
                }
                break;                          
            case 2 : 
                try
                {
              System.out.println("Enter delete position");
                    dh.delete(scan.nextInt() - 1); 
                }
catch (Exception e)
                {
             System.out.println(e.getMessage() );
                }                 
                break;                                      
            case 3 : 
                System.out.println("Full status = "+ dh.isFull());
                break;                                   
            case 4 : 
                System.out.println("Empty status = "+ dh.isEmpty());
                break; 
            case 5 : 
                dh.clear(); 
                System.out.println("Heap Cleared\n");
                break;         
default : 
                System.out.println("Wrong Entry \n ");
                break;   
            } 
            //Display heap 
            dh.printHeap();  
 
            System.out.println("\nDo you want to continue (Type y or n) \n");
            ch = scan.next().charAt(0);                        
        } while (ch == 'Y'|| ch == 'y');  
    }
}
*/

/////winning tree//
/*
import java.util.*;

class Main {
    static class Node {
        int idx;
        Node left, right;

        Node(int idx) {
            this.idx = idx;
            this.left = this.right = null;
        }
    }

    static void traverseHeight(Node root, int[] arr, int[] res) {
        if (root == null || (root.left == null && root.right == null))
            return;
        if (root.left != null && res[0] > arr[root.left.idx] && root.left.idx != root.idx) {
            res[0] = arr[root.left.idx];
            traverseHeight(root.right, arr, res);
        } else if (root.right != null && res[0] > arr[root.right.idx] && root.right.idx != root.idx) {
            res[0] = arr[root.right.idx];
            traverseHeight(root.left, arr, res);
        }
    }

    static void findSecondMin(int[] arr, int n) {
        if (n < 2) {
            System.out.println("Array must have at least 2 elements");
            return;
        }

        List<Node> nodes = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            nodes.add(new Node(i));
        }

        while (nodes.size() > 1) {
            List<Node> newNodes = new ArrayList<>();
            for (int i = 0; i < nodes.size(); i += 2) {
                Node left = nodes.get(i);
                Node right = (i + 1 < nodes.size()) ? nodes.get(i + 1) : null;
                Node parent = new Node(left.idx);
                parent.left = left;
                parent.right = right;
                if (right != null && arr[right.idx] < arr[left.idx]) {
                    parent.idx = right.idx;
                }
                newNodes.add(parent);
            }
            nodes = newNodes;
        }

        int[] res = { Integer.MAX_VALUE };
        traverseHeight(nodes.get(0), arr, res);
        System.out.println("Minimum: " + arr[nodes.get(0).idx] + ", Second minimum: " + res[0]);
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = s.nextInt();
        }
        findSecondMin(arr, n);
    }
}
*/

////recover the bst//
/*
import java.util.*;

class Node {
    int val;
    Node left;
    Node right;

    Node(int data) {
        this.val = data;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    static Node firstIncorrect = null;
    static Node secondIncorrect = null;
    static Node prev = null;

    public static Node buildTree(String s) {
        String[] sArr = s.split(" ");
        Node root = new Node(Integer.parseInt(sArr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sArr.length) {
            Node current = q.poll();
            if (!sArr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sArr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sArr.length)
                break;
            if (!sArr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sArr[i]));
                q.add(current.right);
            }
            i++;
        }
        return root;
    }

    public static void inOrder(Node root) {
        if (root == null)
            return;

        inOrder(root.left);

        if (prev != null && prev.val >= root.val) {
            if (firstIncorrect == null) {
                firstIncorrect = prev;
            }
            secondIncorrect = root;
        }

        prev = root;

        inOrder(root.right);
    }

    public static void recoverTree(Node root) {
        inOrder(root);

        int temp = firstIncorrect.val;
        firstIncorrect.val = secondIncorrect.val;
        secondIncorrect.val = temp;

        printInOrder(root);
    }

    public static void printInOrder(Node root) {
        if (root == null)
            return;

        printInOrder(root.left);
        System.out.print(root.val + " ");
        printInOrder(root.right);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        Node root = buildTree(s);
        prev = new Node(Integer.MIN_VALUE);
        recoverTree(root);
    }
}
*/

// TOP VEW
/*
import java.util.*;
class TreeNode {
    char val;
    TreeNode left;
    TreeNode right;
    public TreeNode(char val) {
        this.val = val;
left = null;
        right = null;
    }
}

public class Main{
    
    public static List<Character> leftView(TreeNode root){
        List<Character> leftView = new ArrayList<>();
        
        if(root == null){
            return leftView;
        }
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            int level = q.size();
            for(int i = 0; i< level; i++){
                TreeNode node = q.poll();
                if(i == 0){
                    leftView.add(node.val);
                }
                
                if(node.left != null){
                    q.add(node.left);
                }
                if(node.right != null){
                    q.add(node.right);
                }
            }
            
        }
        return leftView;
    }
    
    public static List<Character> rightView(TreeNode root){
        List<Character> rightView = new ArrayList<>();
        
        if(root == null){
            return rightView;
        }
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()){
            int level = q.size();
            for(int i = 0; i< level; i++){
                TreeNode node = q.poll();
                if(i == level-1){
                    rightView.add(node.val);
                }
                
                if(node.left != null){
                    q.add(node.left);
                }
                if(node.right != null){
                    q.add(node.right);
                }
            }
            
        }
        return rightView;
    }
    
    public static void main(String args[]){
        TreeNode root = new TreeNode('A');
        root.left = new TreeNode('B');
        root.right = new TreeNode('C');
        root.left.left = new TreeNode('D');
        root.left.right = new TreeNode('E');
        root.right.left = new TreeNode('F');
        root.right.right = new TreeNode('G');
        List<Character> leftViewResult = leftView(root);
        List<Character> rightViewResult = rightView(root);
        Collections.reverse(leftViewResult);
        System.out.print("Left View: ");
        for (char node : leftViewResult)
            System.out.print(node + " ");
        System.out.print("Right View: ");
        for (char node : rightViewResult)
            System.out.print(node + " ");
        
        System.out.println();
    }
}
*/

/// BOUNDARY
/*
class Node {
	int data;
	Node left, right;

	Node(int item)
	{
		data = item;
		left = right = null;
	}
}

public class BinaryTree {
	Node root;

	// A simple function to print leaf nodes of a binary tree
	void printLeaves(Node node)
	{
		if (node == null)
			return;

		printLeaves(node.left);
		// Print it if it is a leaf node
		if (node.left == null && node.right == null)
			System.out.print(node.data + " ");
		printLeaves(node.right);
	}

	// A function to print all left boundary nodes, except a leaf node.
	// Print the nodes in TOP DOWN manner
	void printBoundaryLeft(Node node)
	{
		if (node == null)
			return;

		if (node.left != null) {
			// to ensure top down order, print the node
			// before calling itself for left subtree
			System.out.print(node.data + " ");
			printBoundaryLeft(node.left);
		}
		else if (node.right != null) {
			System.out.print(node.data + " ");
			printBoundaryLeft(node.right);
		}

		// do nothing if it is a leaf node, this way we avoid
		// duplicates in output
	}

	// A function to print all right boundary nodes, except a leaf node
	// Print the nodes in BOTTOM UP manner
	void printBoundaryRight(Node node)
	{
		if (node == null)
			return;

		if (node.right != null) {
			// to ensure bottom up order, first call for right
			// subtree, then print this node
			printBoundaryRight(node.right);
			System.out.print(node.data + " ");
		}
		else if (node.left != null) {
			printBoundaryRight(node.left);
			System.out.print(node.data + " ");
		}
		// do nothing if it is a leaf node, this way we avoid
		// duplicates in output
	}

	// A function to do boundary traversal of a given binary tree
	void printBoundary(Node node)
	{
		if (node == null)
			return;

		System.out.print(node.data + " ");

		// Print the left boundary in top-down manner.
		printBoundaryLeft(node.left);

		// Print all leaf nodes
		printLeaves(node.left);
		printLeaves(node.right);

		// Print the right boundary in bottom-up manner
		printBoundaryRight(node.right);
	}

	// Driver program to test above functions
	public static void main(String args[])
	{
	    
	   // TreeNode root = new TreeNode(8);
    //     root.left = new TreeNode(3);
    //     root.right = new TreeNode(10);
    //     root.left.left = new TreeNode(1);
    //     root.left.right = new TreeNode(6);
    //     root.left.right.left = new TreeNode(4);
    //     root.left.right.right = new TreeNode(7);
    //     root.right.right = new TreeNode(14);
    //     root.right.right.left = new TreeNode(13);

		BinaryTree tree = new BinaryTree();
		tree.root = new Node(8);
		tree.root.left = new Node(3);
		tree.root.left.left = new Node(10);
		tree.root.left.right = new Node(1);
		tree.root.left.right.left = new Node(6);
		tree.root.left.right.right = new Node(4);
		tree.root.right = new Node(7);
		tree.root.right.right = new Node(14);
		tree.printBoundary(tree.root);
	}
}
*/


// LEVEL ORDER TRAVERSAL
/*
import java.util.*;
public class Main {
    public static Tree build(int[] nums){
        Tree root = new Tree(nums[0]);
        Queue<Tree> q = new LinkedList<>();
        q.add(root);
        
        int i = 1;
        
        while(i < nums.length){
            Tree curr = q.remove();
            
            if(i < nums.length){
                curr.left = new Tree(nums[i++]);
                q.add(curr.left);
            }
            
            if (i < nums.length){
                curr.right = new Tree(nums[i++]);
                q.add(curr.right);
            }
        }
        return root;
    }
    
    public static void printTree(Tree root){
        if (root == null){
            return;
        }
        printTree(root.left);
        System.out.println(root.val);
        printTree(root.right);
    }
    
    public static void levelOrder(Tree root){
        int h = height(root);
        
        for(int i = 1; i<=h; i++){
            printLO(root, i);
            System.out.println();
        }
    }
    
    public static void printLO(Tree root, int i ){
        if(root == null){
            return;
        }
        
        if(i == 1){
            System.out.print(root.val + " ");
        }
        else if(i>1){
            printLO(root.left, i-1);
            printLO(root.right, i-1);
        }
    }
    
    public static int height(Tree root){
        if(root == null){
            return 0;
        }
        
        int lh = height(root.left);
        int rh = height(root.right);
        
        return 1+Math.max(lh, rh);
    } 
    
    public static void main(String[] args) {
        int [] nums = {1, 2, 3, 4, 5, 6, 7, 8};
        Tree root = build(nums);
        printTree(root);
        levelOrder(root);
    }
}

class Tree{
    int val;
    Tree left, right;
    
    Tree(int x){
        val = x;
        left = null;
        right = null;
    }
}
*/

// BUILDER 
/*
import java.util.*;

class Main {
    public static TreeNode buildTree(int[] nums){
    if(nums == null || nums.length == 0) {
        return null;
    }
    Queue<TreeNode> q = new LinkedList<>();
    TreeNode root = new TreeNode(nums[0]);
    q.add(root);
    int i = 1;
    while(i < nums.length){
        TreeNode curr = q.remove();
        if(i < nums.length){
            curr.left = new TreeNode(nums[i++]);
            q.add(curr.left);
        }
        
        if(i < nums.length){
            curr.right = new TreeNode(nums[i++]);
            q.add(curr.right);
        }
    }
    return root;
}
public static void printTree(TreeNode root){
    if(root == null){
        return;
    }
    printTree(root.left);
    System.out.println(root.val);
    printTree(root.right);
}
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        int nums[] = {1, 2, 3, 4, 5, 6, 7, 8};
        
        TreeNode root = buildTree(nums);
        printTree(root);
    }
}

 class TreeNode{
    int val;
    TreeNode left, right;
    
    TreeNode(int x){
        val = x;
        left = null;
        right = null;
    }
}
*/

////bellman's
/*
import java.util.*;

public class BellmanFordAlgorithm {
    static class Edge {
        int source, dest, weight;

        Edge(int source, int dest, int weight) {
            this.source = source;
            this.dest = dest;
            this.weight = weight;
        }
    }

    static class Graph {
        int V, E;
        Edge[] edges;

        Graph(int V, int E) {
            this.V = V;
            this.E = E;
            edges = new Edge[E];
        }

        void addEdge(int index, int source, int dest, int weight) {
            edges[index] = new Edge(source, dest, weight);
        }

        void bellmanFord(int source) {
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MAX_VALUE);
            dist[source] = 0;

            // Relax all edges V-1 times
            for (int i = 0; i < V - 1; i++) {
                for (int j = 0; j < E; j++) {
                    int u = edges[j].source;
                    int v = edges[j].dest;
                    int weight = edges[j].weight;
                    if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                        dist[v] = dist[u] + weight;
                    }
                }
            }

            // Check for negative-weight cycles
            for (int i = 0; i < E; i++) {
                int u = edges[i].source;
                int v = edges[i].dest;
                int weight = edges[i].weight;
                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                    System.out.println("Graph contains negative-weight cycle.");
                    return;
                }
            }

            // Print the shortest distances from source to all vertices
            System.out.println("Shortest distances from source vertex " + source + ":");
            for (int i = 0; i < V; i++) {
                System.out.println("Vertex " + i + ": " + dist[i]);
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices: ");
        int V = scanner.nextInt();

        System.out.print("Enter the number of edges: ");
        int E = scanner.nextInt();

        Graph graph = new Graph(V, E);

        System.out.println("Enter the edges and their weights (source destination weight):");
        for (int i = 0; i < E; i++) {
            int source = scanner.nextInt();
            int dest = scanner.nextInt();
            int weight = scanner.nextInt();
            graph.addEdge(i, source, dest, weight);
        }

        System.out.print("Enter the source vertex: ");
        int source = scanner.nextInt();

        graph.bellmanFord(source);
    }
}*/

/////topological sort
/*
import java.util.*;

public class TopologicalSort {

	// Function to perform DFS and topological sorting
	static void topologicalSortUtil(int v, List<List<Integer>> adj,
									boolean[] visited,
									Stack<Integer> stack)
	{
		// Mark the current node as visited
		visited[v] = true;

		// Recur for all adjacent vertices
		for (int i : adj.get(v)) {
			if (!visited[i])
				topologicalSortUtil(i, adj, visited, stack);
		}

		// Push current vertex to stack which stores the
		// result
		stack.push(v);
	}

	// Function to perform Topological Sort
	static void topologicalSort(List<List<Integer>> adj, int V)
	{
		// Stack to store the result
		Stack<Integer> stack = new Stack<>();
		boolean[] visited = new boolean[V];

		// Call the recursive helper function to store
		// Topological Sort starting from all vertices one
		// by one
		for (int i = 0; i < V; i++) {
			if (!visited[i])
				topologicalSortUtil(i, adj, visited, stack);
		}

		// Print contents of stack
		System.out.print("Topological sorting of the graph: ");
		while (!stack.empty()) {
			System.out.print(stack.pop() + " ");
		}
		System.out.println();
	}

	// Driver code
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices: ");
		int V = scanner.nextInt();

		List<List<Integer>> adj = new ArrayList<>(V);
		for (int i = 0; i < V; i++) {
			adj.add(new ArrayList<>());
		}

		System.out.print("Enter the number of edges: ");
		int E = scanner.nextInt();
		System.out.println("Enter the edges (source destination): ");
		for (int i = 0; i < E; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			adj.get(source).add(destination);
		}

		topologicalSort(adj, V);
	}
}*/

////heap sort
/*
import java.util.Arrays;
import java.util.Scanner;

public class SortingExample {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the number of elements
        System.out.print("Enter the number of elements: ");
        int n = scanner.nextInt();

        // Create an array to store the elements
        int[] arr = new int[n];

        // Prompt the user to enter the elements
        System.out.println("Enter the elements:");

        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Sort the array
        Arrays.sort(arr);

        // Print the sorted array
        System.out.println("Sorted array:");
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}*/

//////bfs
/*
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

// Class to represent a graph using adjacency list
class Graph {
	int vertices;
	LinkedList<Integer>[] adjList;

	@SuppressWarnings("unchecked") Graph(int vertices)
	{
		this.vertices = vertices;
		adjList = new LinkedList[vertices];
		for (int i = 0; i < vertices; ++i)
			adjList[i] = new LinkedList<>();
	}

	// Function to add an edge to the graph
	void addEdge(int u, int v) { adjList[u].add(v); }

	// Function to perform Breadth First Search on a graph
	// represented using adjacency list
	void bfs(int startNode)
	{
		// Create a queue for BFS
		Queue<Integer> queue = new LinkedList<>();
		boolean[] visited = new boolean[vertices];

		// Mark the current node as visited and enqueue it
		visited[startNode] = true;
		queue.add(startNode);

		// Iterate over the queue
		while (!queue.isEmpty()) {
			// Dequeue a vertex from queue and print it
			int currentNode = queue.poll();
			System.out.print(currentNode + " ");

			// Get all adjacent vertices of the dequeued
			// vertex currentNode If an adjacent has not
			// been visited, then mark it visited and
			// enqueue it
			for (int neighbor : adjList[currentNode]) {
				if (!visited[neighbor]) {
					visited[neighbor] = true;
					queue.add(neighbor);
				}
			}
		}
	}
}

public class Main {
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices in the graph: ");
		int vertices = scanner.nextInt();

		// Create a graph
		Graph graph = new Graph(vertices);

		System.out.print("Enter the number of edges: ");
		int edges = scanner.nextInt();

		System.out.println("Enter the edges (source destination):");
		for (int i = 0; i < edges; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			graph.addEdge(source, destination);
		}

		// Perform BFS traversal starting from vertex 0
		System.out.print(
			"Breadth First Traversal starting from vertex 0: ");
		graph.bfs(0);
	}
}*/

/////dfs
/*
import java.util.*;

// This class represents a
// directed graph using adjacency
// list representation
class Main {
	private int V;
	private LinkedList<Integer>[] adj;

	// Constructor
	@SuppressWarnings("unchecked")
	Main(int v)
	{
		V = v;
		adj = new LinkedList[v];
		for (int i = 0; i < v; ++i)
			adj[i] = new LinkedList<>();
	}

	// Function to add an edge into the graph
	void addEdge(int v, int w)
	{
		// Add w to v's list.
		adj[v].add(w);
	}

	// A function used by DFS
	void DFSUtil(int v, boolean visited[])
	{
		// Mark the current node as visited and print it
		visited[v] = true;
		System.out.print(v + " ");

		// Recur for all the vertices adjacent to this vertex
		Iterator<Integer> i = adj[v].listIterator();
		while (i.hasNext()) {
			int n = i.next();
			if (!visited[n])
				DFSUtil(n, visited);
		}
	}

	// The function to do DFS traversal.
	// It uses recursive DFSUtil()
	void DFS(int v)
	{
		// Mark all the vertices as not visited(set as false by default in java)
		boolean visited[] = new boolean[V];

		// Call the recursive helper function to print DFS traversal
		DFSUtil(v, visited);
	}

	// Driver Code
	public static void main(String args[])
	{
		Scanner scanner = new Scanner(System.in);

		System.out.print("Enter the number of vertices in the graph: ");
		int V = scanner.nextInt();
		Main g = new Main(V);

		System.out.print("Enter the number of edges: ");
		int E = scanner.nextInt();
		System.out.println("Enter the edges (source destination):");
		for (int i = 0; i < E; i++) {
			int source = scanner.nextInt();
			int destination = scanner.nextInt();
			g.addEdge(source, destination);
		}

		System.out.print("Enter the starting vertex for DFS traversal: ");
		int startVertex = scanner.nextInt();

		System.out.println("Depth First Traversal:");
		g.DFS(startVertex);
	}
}*/

////vertical order traversal
/*
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.Vector;
import java.util.*;

public class Main {
	// Tree node
	static class Node {
		int key;
		Node left;
		Node right;

		// Constructor
		Node(int data)
		{
			key = data;
			left = null;
			right = null;
		}
	}
     static Node buildTree(String s) {
        String[] sarr = s.split("\\s+");
        Node root = new Node(Integer.parseInt(sarr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sarr.length) {
            Node current = q.poll();
            if (!sarr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sarr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sarr.length) {
                break;
            }
            if (!sarr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sarr[i]));
                q.add(current.right);
            }
            i++;
        }

        return root;
    }

	// Utility function to store vertical order in map 'm'
	// 'hd' is horizontal distance of current node from
	// root. 'hd' is initially passed as 0
	static void
	getVerticalOrder(Node root, int hd,
					TreeMap<Integer, Vector<Integer> > m)
	{
		// Base case
		if (root == null)
			return;

		// get the vector list at 'hd'
		Vector<Integer> get = m.get(hd);

		// Store current node in map 'm'
		if (get == null) {
			get = new Vector<>();
			get.add(root.key);
		}
		else
			get.add(root.key);

		m.put(hd, get);

		// Store nodes in left subtree
		getVerticalOrder(root.left, hd - 1, m);

		// Store nodes in right subtree
		getVerticalOrder(root.right, hd + 1, m);
	}

	// The main function to print vertical order of a binary
	// tree with the given root
	static void printVerticalOrder(Node root)
{
    // Create a map and store vertical order in map
    // using function getVerticalOrder()
    TreeMap<Integer, Vector<Integer> > m
        = new TreeMap<>();
    int hd = 0;
    getVerticalOrder(root, hd, m);

    // Traverse the map and print nodes at every
    // horizontal distance (hd)
    for (Entry<Integer, Vector<Integer> > entry :
        m.entrySet()) {
        Vector<Integer> nodes = entry.getValue();
        for (Integer node : nodes) {
            System.out.print(node + " ");
        }
        System.out.println();
    }
}

	// Driver code
	public static void main(String[] args)
	{

	    Scanner sc=new Scanner(System.in);
	    String s=sc.nextLine();
	    Node root=buildTree(s);
		System.out.println("Vertical Order traversal is");
		printVerticalOrder(root);
	}
}
*/

/////boundary traversal
/*
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
    static class Node {
        int data;
        Node left, right;

        Node(int item) {
            data = item;
            left = right = null;
        }
    }

    Node root;

    static Node buildTree(String s) {
        String[] sarr = s.split("\\s+");
        Node root = new Node(Integer.parseInt(sarr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sarr.length) {
            Node current = q.poll();
            if (!sarr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sarr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sarr.length) {
                break;
            }
            if (!sarr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sarr[i]));
                q.add(current.right);
            }
            i++;
        }

        return root;
    }

    // A simple function to print leaf nodes of a binary tree
    void printLeaves(Node node) {
        if (node == null)
            return;

        printLeaves(node.left);
        // Print it if it is a leaf node
        if (node.left == null && node.right == null)
            System.out.print(node.data + " ");
        printLeaves(node.right);
    }

    // A function to print all left boundary nodes, except a leaf node.
    // Print the nodes in TOP DOWN manner
    void printBoundaryLeft(Node node) {
        if (node == null)
            return;

        if (node.left != null) {
            // to ensure top down order, print the node
            // before calling itself for left subtree
            System.out.print(node.data + " ");
            printBoundaryLeft(node.left);
        } else if (node.right != null) {
            System.out.print(node.data + " ");
            printBoundaryLeft(node.right);
        }

        // do nothing if it is a leaf node, this way we avoid
        // duplicates in output
    }

    // A function to print all right boundary nodes, except a leaf node
    // Print the nodes in BOTTOM UP manner
    void printBoundaryRight(Node node) {
        if (node == null)
            return;

        if (node.right != null) {
            // to ensure bottom up order, first call for right
            // subtree, then print this node
            printBoundaryRight(node.right);
            System.out.print(node.data + " ");
        } else if (node.left != null) {
            printBoundaryRight(node.left);
            System.out.print(node.data + " ");
        }
        // do nothing if it is a leaf node, this way we avoid
        // duplicates in output
    }

    // A function to do boundary traversal of a given binary tree
    void printBoundary(Node node) {
        if (node == null)
            return;

        System.out.print(node.data + " ");

        // Print the left boundary in top-down manner.
        printBoundaryLeft(node.left);

        // Print all leaf nodes
        printLeaves(node.left);
        printLeaves(node.right);

        // Print the right boundary in bottom-up manner
        printBoundaryRight(node.right);
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        Main tree = new Main();

        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        tree.root = buildTree(s);
        System.out.println("Boundary Traversal of binary tree is ");
        tree.printBoundary(tree.root);
    }
}
*/

////views of tree///
/*
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    public TreeNode(int value) {
        val = value;
        left = right = null;
    }
}

public class TreeViews {

    // Function to perform a level order traversal
    private static List<List<Integer>> levelOrderTraversal(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null)
            return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();
                currentLevel.add(currentNode.val);

                if (currentNode.left != null)
                    queue.offer(currentNode.left);
                if (currentNode.right != null)
                    queue.offer(currentNode.right);
            }
            result.add(currentLevel);
        }
        return result;
    }

    // Function to print the horizontal view of the binary tree
    public static void horizontalView(TreeNode root) {
        Map<Integer, List<Integer>> horizontalMap = new TreeMap<>();
        horizontalViewHelper(root, horizontalMap, 0);

        for (List<Integer> levelNodes : horizontalMap.values()) {
            for (Integer val : levelNodes) {
                System.out.print(val + " ");
            }
        }
    }

    private static void horizontalViewHelper(TreeNode node, Map<Integer, List<Integer>> horizontalMap, int depth) {
        if (node == null)
            return;

        List<Integer> levelNodes = horizontalMap.getOrDefault(depth, new ArrayList<>());
        levelNodes.add(node.val);
        horizontalMap.put(depth, levelNodes);

        horizontalViewHelper(node.left, horizontalMap, depth + 1);
        horizontalViewHelper(node.right, horizontalMap, depth + 1);
    }

    // Function to print the vertical view of the binary tree
    public static void verticalView(TreeNode root) {
        TreeMap<Integer, List<Integer>> verticalMap = new TreeMap<>();
        verticalViewHelper(root, verticalMap, 0);

        for (List<Integer> levelNodes : verticalMap.values()) {
            for (Integer val : levelNodes) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }

    private static void verticalViewHelper(TreeNode node, TreeMap<Integer, List<Integer>> verticalMap, int level) {
        if (node == null)
            return;

        List<Integer> levelNodes = verticalMap.getOrDefault(level, new ArrayList<>());
        levelNodes.add(node.val);
        verticalMap.put(level, levelNodes);

        verticalViewHelper(node.left, verticalMap, level - 1);
        verticalViewHelper(node.right, verticalMap, level + 1);
    }

    // Function to print the left view of the binary tree
    public static void leftView(TreeNode root) {
        leftViewHelper(root, 1);
    }

    private static int maxLevel = 0;

    private static void leftViewHelper(TreeNode node, int level) {
        if (node == null)
            return;

        if (level > maxLevel) {
            System.out.print(node.val + " ");
            maxLevel = level;
        }

        leftViewHelper(node.left, level + 1);
        leftViewHelper(node.right, level + 1);
    }

    // Function to print the right view of the binary tree
    public static void rightView(TreeNode root) {
        maxLevel = 0;
        rightViewHelper(root, 1);
    }

    private static void rightViewHelper(TreeNode node, int level) {
        if (node == null)
            return;

        if (level > maxLevel) {
            System.out.print(node.val + " ");
            maxLevel = level;
        }

        rightViewHelper(node.right, level + 1);
        rightViewHelper(node.left, level + 1);
    }

    // Function to print the top view of the binary tree
    public static void topView(TreeNode root) {
        TreeMap<Integer, Integer> topViewMap = new TreeMap<>();
        topViewHelper(root, topViewMap, 0);

        for (Integer val : topViewMap.values()) {
            System.out.print(val + " ");
        }
    }

    private static void topViewHelper(TreeNode node, TreeMap<Integer, Integer> topViewMap, int level) {
        if (node == null)
            return;

        if (!topViewMap.containsKey(level)) {
            topViewMap.put(level, node.val);
        }

        topViewHelper(node.left, topViewMap, level - 1);
        topViewHelper(node.right, topViewMap, level + 1);
    }

    // Function to print the bottom view of the binary tree
    public static void bottomView(TreeNode root) {
        TreeMap<Integer, Integer> bottomViewMap = new TreeMap<>();
        bottomViewHelper(root, bottomViewMap, 0);

        for (Integer val : bottomViewMap.values()) {
            System.out.print(val + " ");
        }
    }

    private static void bottomViewHelper(TreeNode node, TreeMap<Integer, Integer> bottomViewMap, int level) {
        if (node == null)
            return;

        bottomViewMap.put(level, node.val);

        bottomViewHelper(node.left, bottomViewMap, level - 1);
        bottomViewHelper(node.right, bottomViewMap, level + 1);
    }

    // Function to build the binary tree from array input
    public static TreeNode buildTree(Integer[] array, int index) {
        TreeNode root = null;
        if (index < array.length && array[index] != null) {
            root = new TreeNode(array[index]);
            root.left = buildTree(array, 2 * index + 1);
            root.right = buildTree(array, 2 * index + 2);
        }
        return root;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the elements of the binary tree separated by spaces (use null for missing nodes):");
        String[] input = scanner.nextLine().split(" ");

        Integer[] array = new Integer[input.length];
        for (int i = 0; i < input.length; i++) {
            if (input[i].equals("null")) {
                array[i] = null;
            } else {
                array[i] = Integer.parseInt(input[i]);
            }
        }

        TreeNode root = buildTree(array, 0);

        System.out.println("Horizontal View:");
        horizontalView(root);
        System.out.println("\nVertical View:");
        verticalView(root);
        System.out.println("\nLeft View:");
        leftView(root);
        System.out.println("\nRight View:");
        rightView(root);
        System.out.println("\nTop View:");
        topView(root);
        System.out.println("\nBottom View:");
        bottomView(root);

        scanner.close();
    }
}
*/

////binomila heap
/*
import java.util.*;

class BinomialHeapNode {
    int key, degree;
    BinomialHeapNode parent, child, sibling;

    public BinomialHeapNode(int key) {
        this.key = key;
        this.degree = 0;
        this.parent = this.child = this.sibling = null;
    }
}

public class BinomialHeap {
    private BinomialHeapNode head;

    public BinomialHeap() {
        head = null;
    }

    private BinomialHeapNode mergeTrees(BinomialHeapNode tree1, BinomialHeapNode tree2) {
        if (tree1.key < tree2.key) {
            tree1.sibling = tree2.child;
            tree2.child = tree1;
            return tree2;
        } else {
            tree2.sibling = tree1.child;
            tree1.child = tree2;
            return tree1;
        }
    }

    private BinomialHeapNode mergeHeaps(BinomialHeapNode heap1, BinomialHeapNode heap2) {
        BinomialHeapNode dummy = new BinomialHeapNode(0);
        BinomialHeapNode current = dummy;

        while (heap1 != null && heap2 != null) {
            if (heap1.degree <= heap2.degree) {
                current.sibling = heap1;
                heap1 = heap1.sibling;
            } else {
                current.sibling = heap2;
                heap2 = heap2.sibling;
            }
            current = current.sibling;
        }

        current.sibling = (heap1 != null) ? heap1 : heap2;
        return dummy.sibling;
    }

    public void insert(int key) {
        BinomialHeapNode newNode = new BinomialHeapNode(key);
        head = mergeHeaps(head, newNode);
        BinomialHeapNode prev = null;
        BinomialHeapNode current = head;
        BinomialHeapNode next = current.sibling;

        while (next != null) {
            if ((current.degree != next.degree) || (next.sibling != null && next.sibling.degree == current.degree)) {
                prev = current;
                current = next;
            } else {
                if (current.key <= next.key) {
                    current.sibling = next.sibling;
                    current = mergeTrees(current, next);
                } else {
                    if (prev == null) {
                        head = next;
                    } else {
                        prev.sibling = next;
                    }
                    current = mergeTrees(next, current);
                    current = next;
                }
            }
            next = current.sibling;
        }
    }

    public void deleteMin() {
        if (head == null) {
            System.out.println("Heap is empty");
            return;
        }

        BinomialHeapNode minPrev = null;
        BinomialHeapNode minCurrent = head;
        BinomialHeapNode current = minCurrent.sibling;
        BinomialHeapNode prev = minCurrent;

        while (current != null) {
            if (current.key < minCurrent.key) {
                minCurrent = current;
                minPrev = prev;
            }
            prev = current;
            current = current.sibling;
        }

        if (minPrev == null) {
            head = minCurrent.sibling;
        } else {
            minPrev.sibling = minCurrent.sibling;
        }

        BinomialHeapNode newHead = null;
        BinomialHeapNode child = minCurrent.child;

        while (child != null) {
            BinomialHeapNode next = child.sibling;
            child.sibling = newHead;
            newHead = child;
            child = next;
        }

        BinomialHeapNode newHeap = mergeHeaps(head, newHead);
        head = newHeap;
    }

    public void displayHeap(BinomialHeapNode node) {
        while (node != null) {
            System.out.print(node.key + " ");
            displayHeap(node.child);
            node = node.sibling;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BinomialHeap heap = new BinomialHeap();

        while (true) {
            System.out.println("\n1. Insert");
            System.out.println("2. Delete Min");
            System.out.println("3. Display");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter key to insert: ");
                    int key = scanner.nextInt();
                    heap.insert(key);
                    break;
                case 2:
                    heap.deleteMin();
                    System.out.println("Min deleted");
                    break;
                case 3:
                    System.out.print("Heap: ");
                    heap.displayHeap(heap.head);
                    break;
                case 4:
                    scanner.close();
                    System.exit(0);
                default:
                    System.out.println("Invalid choice");
            }
        }
    }
}*/

/////recover bst
/*
import java.util.*;

class Node {
    int val;
    Node left;
    Node right;

    Node(int data) {
        this.val = data;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    static Node firstIncorrect = null;
    static Node secondIncorrect = null;
    static Node prev = null;

    public static Node buildTree(String s) {
        String[] sArr = s.split(" ");
        Node root = new Node(Integer.parseInt(sArr[0]));
        Queue<Node> q = new LinkedList<>();
        int i = 1;
        q.add(root);
        while (!q.isEmpty() && i < sArr.length) {
            Node current = q.poll();
            if (!sArr[i].equals("-1")) {
                current.left = new Node(Integer.parseInt(sArr[i]));
                q.add(current.left);
            }
            i++;
            if (i >= sArr.length)
                break;
            if (!sArr[i].equals("-1")) {
                current.right = new Node(Integer.parseInt(sArr[i]));
                q.add(current.right);
            }
            i++;
        }
        return root;
    }

    public static void inOrder(Node root) {
        if (root == null)
            return;

        inOrder(root.left);

        if (prev != null && prev.val >= root.val) {
            if (firstIncorrect == null) {
                firstIncorrect = prev;
            }
            secondIncorrect = root;
        }

        prev = root;

        inOrder(root.right);
    }

    public static void recoverTree(Node root) {
        inOrder(root);

        int temp = firstIncorrect.val;
        firstIncorrect.val = secondIncorrect.val;
        secondIncorrect.val = temp;

        printInOrder(root);
    }

    public static void printInOrder(Node root) {
        if (root == null)
            return;

        printInOrder(root.left);
        System.out.print(root.val + " ");
        printInOrder(root.right);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        Node root = buildTree(s);
        prev = new Node(Integer.MIN_VALUE);
        recoverTree(root);
    }
}	
*/
